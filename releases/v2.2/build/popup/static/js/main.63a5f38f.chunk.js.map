{"version":3,"sources":["helpers/CookieHelper.tsx","hooks/useDebounce.ts","store/GlobalStore.tsx","App.tsx","index.tsx"],"names":["groupCookiesByDomain","groupBy","cookie","domain","sortCookiesByDomain","sortBy","mappedCookies","length","getCookiesSize","cookies","returnNumber","sizes","map","calculateOneCookieSize","size","sum","humanReadableSize","toFixed","getSizeOfValues","args","Buffer","byteLength","join","humanReadable","name","value","getCurrentUrlFromTab","fullUrl","R","parsedDomainUrl","parseDomain","subdomain","tld","formatNewCookie","currentUrl","secure","indexOf","hostOnlyDomain","substr","substring","expirationDate","getUnixTime","parse","expirationDateString","Date","hostOnly","Boolean","url","path","getURL","URL","hostname","replace","error","currentTab","a","browser","tabs","query","active","currentWindow","tab","getAllCookies","parsedDomain","getAll","Object","entries","key","formatedSize","cookieSize","expirationMessage","getExpirationDate","getExpirationDateString","badges","generateBadges","session","formatDistanceToNow","fromUnixTime","time","format","addHours","httpOnly","push","badgeName","useDebounce","delay","useState","debouncedValue","setDebouncedValue","useEffect","handler","setTimeout","clearTimeout","DEFAULT_GLOBAL_CONTEXT","domainCookies","loading","newCookie","StoreContext","createContext","state","setState","Store","props","window","easyCookieEditor","memoizedSetState","useMemo","prev","editCookie","clearCookie","setCurrentTab","_currentTab","loadAllComainCookies","JSON","stringify","debouncedState","onChanged","addListener","removeListener","Provider","children","MainScreen","React","lazy","theme","createMuiTheme","palette","type","App","ThemeProvider","fallback","ReactDOM","render","document","getElementById"],"mappings":"ygBA4BaA,EAAuBC,aAClC,SAACC,GAAD,OAAwBA,EAAOC,UAEpBC,EAAsBC,aACjC,SAACC,GAAD,OAAoCA,EAAcH,OAAOI,UAW9CC,EAAiB,SAC5BC,GAEI,IADJC,EACG,wDACGC,EAAQF,EAAQG,KAAI,SAAAV,GAAM,OAAIW,EAAuBX,MACrDY,EAAOC,YAAIJ,GACjB,OAAID,EAAqBI,EAClBE,EAAkBF,IAGdE,EAAoB,SAACF,GAAD,OAC/BA,EAAO,IAAP,WAAkBA,EAAO,KAAMG,QAAQ,GAAvC,iBAAoDH,EAApD,WAEWI,EAAkB,sCAAIC,EAAJ,yBAAIA,EAAJ,uBAC7BC,EAAOC,WAAWF,EAAKG,KAAK,MAEjBT,EAAyB,SACpCX,GAEI,IADJqB,EACG,wDACGT,EAAOI,EAAgBhB,EAAOsB,KAAMtB,EAAOuB,OACjD,OAAIF,EAAsBP,EAAkBF,GACrCA,GAGIY,EAAuB,SAACC,GACnC,GAAIC,IAAUD,IAAYC,IAAQD,GAChC,OAAO,KAGT,IAAME,EAAkBC,IAAYH,GACpC,OAAKE,EAK4B,MAAhB,OAAfA,QAAe,IAAfA,OAAA,EAAAA,EAAiBE,YAAmD,SAAhB,OAAfF,QAAe,IAAfA,OAAA,EAAAA,EAAiBE,WAClD,CAACF,EAAgB1B,OAAQ0B,EAAgBG,KAAKV,KAAK,KACnD,QACEO,QADF,IACEA,OADF,EACEA,EAAiBE,UADnB,OAEEF,QAFF,IAEEA,OAFF,EAEEA,EAAiB1B,OAFnB,OAGE0B,QAHF,IAGEA,OAHF,EAGEA,EAAiBG,KACjBV,KAAK,KAVJ,MAcEW,EAAkB,SAC7B/B,EACAgC,GAEA,IAUMC,EAA4C,IAAnCD,EAAWE,QAAQ,YAC5BC,EAC2B,MAA/BnC,EAAOC,OAAOmC,OAAO,EAAG,GACpBpC,EAAOC,OAAOoC,UAAU,GACxBrC,EAAOC,OAEb,OAAO,eACFyB,IAjBgD,CACnD,OACA,UACA,QACA,iBACA,OACA,WACA,UAUG,eACE1B,EADF,CAEDsC,eAAgBC,YACdC,YAAMxC,EAAOyC,qBA9EW,qBA8E6B,IAAIC,UAJ/D,IAOO1C,EAAO2C,UAAYC,QAAuC,MAA/B5C,EAAOC,OAAOmC,OAAO,EAAG,IACpD,CAAEnC,OAAQkC,GACV,GATN,CAUEU,IAAI,OAAD,OAASZ,EAAS,IAAM,GAAxB,cAAgCE,GAAhC,OAAiDnC,EAAO8C,SAIlDC,EAAS,SAACF,GACrB,IAAKA,EAAK,MAAO,GACjB,IACE,IAAM5C,EAAS,IAAI+C,IAAIH,GAAKI,SAC5B,MAAkB,WAAXhD,EAAsB,GAAKA,EAAOiD,QAAQ,OAAQ,IACzD,MAAOC,GACP,MAAO,KAIEC,EAAU,uCAAG,4BAAAC,EAAA,sEACNC,UAAQC,KAAKC,MAAM,CACnCC,QAAQ,EACRC,eAAe,IAHO,cAClBC,EADkB,yBAKjBA,EAAI,IALa,2CAAH,qDAQVC,EAAa,uCAAG,kCAAAP,EAAA,sEACTD,IADS,cACrBO,EADqB,OAErBE,EAAejC,IAAY+B,EAAId,KAFV,SAILS,UAAQ/C,QAAQuD,OACpCD,EACI,CACE5D,OAAO,GAAD,OAAK4D,EAAa5D,OAAlB,YAA4B4D,EAAa/B,MAEjD,CAAEe,IAAKc,EAAId,MATU,cAIrBtC,EAJqB,OAYrBH,EAAgB2D,OAAOC,QAAQlE,EAAqBS,IAAUG,KAClE,YAAmB,IAAD,mBAAhBuD,EAAgB,KAAX1C,EAAW,KACVX,EAAON,EAAeiB,GAAO,GACnC,MAAO,CACLtB,OAAQgE,EACRrD,OACAsD,aAAcpD,EAAkBF,GAChCL,QAASgB,EAAMb,KAAI,SAACV,GAClB,IAAMmE,EAAaxD,EAAuBX,GAW1C,OAVmC,eAC9BA,EAD8B,CAEjCY,KAAMuD,EACND,aAAcpD,EAAkBqD,GAChCC,kBAAmBC,EAAkBrE,GACrCyC,qBAAsB6B,EACpBtE,EAAOsC,gBAETiC,OAAQC,EAAexE,WAM/B,IAnCyB,kBAqCpBE,EAAoBE,IArCA,2CAAH,qDA6CbiE,EAAoB,SAACrE,GAChC,OAAIA,EAAOyE,QAAgB,UACtBzE,EAAOsC,eAELoC,YAAoBC,YAAa3E,EAAOsC,iBAFZ,MAKxBgC,EAA0B,WAEjC,IADJM,EACG,uDAD+B,KAElC,OAAOC,YACLD,EAAOD,YAAaC,GAAQE,YAAS,IAAIpC,KAAQ,GAlKrB,uBAuKnB8B,EAAiB,SAACxE,GAC7B,IAAIuE,EAA2B,GAW/B,OATIvE,EAAO+E,UACTR,EAAOS,KAAK,CACVC,UAAW,aAEXjF,EAAOiC,QACTsC,EAAOS,KAAK,CACVC,UAAW,WAGRV,K,qICxMMW,EAZK,SAAC3D,GAAqC,IAAzB4D,EAAwB,uDAAR,IAAQ,EACXC,mBAAS7D,GADE,mBAChD8D,EADgD,KAChCC,EADgC,KASvD,OAPAC,qBAAU,WACR,IAAMC,EAAUC,YAAW,WACzBH,EAAkB/D,KACjB4D,GACH,OAAO,kBAAMO,aAAaF,MACzB,CAACjE,EAAO4D,IAEJE,G,kCCST,IAAMM,EAAuC,CAC3CC,cAAe,GACfC,SAAS,EACT7F,OAAQ,KACR8F,WAAW,EACX1C,WAAY,MAWD2C,EAAeC,wBAK1B,CAAEC,MAAON,EAAwBO,SAAU,OAsE9BC,IA7Df,SAAeC,GAAe,IAAD,EACDhB,mBAASO,GADR,mBACpBM,EADoB,KACbC,EADa,KAG3BG,OAAOC,iBAAmBL,EAE1B,IAAMM,EAAmBC,mBAAQ,WAqB/B,MApBgC,CAC9BV,UAAW,kBAAMI,GAAS,SAAAO,GAAI,sBAAUA,EAAV,CAAgBX,WAAW,QACzDY,WAAY,SAAA1G,GAAM,OAAIkG,GAAS,SAAAO,GAAI,sBAAUA,EAAV,CAAgBzG,eACnD2G,YAAa,kBACXT,GAAS,SAAAO,GAAI,sBAAUA,EAAV,CAAgBzG,OAAQ,KAAM8F,WAAW,QACxDc,cAAc,WAAD,4BAAE,4BAAAvD,EAAA,sEACaD,cADb,OACPyD,EADO,OAEbX,GAAS,SAAAO,GAAI,sBAAUA,EAAV,CAAgBrD,WAAYyD,OAF5B,2CAAF,kDAAC,GAIdC,qBAAqB,WAAD,4BAAE,4BAAAzD,EAAA,sEACQO,cADR,OACdgC,EADc,OAGlBmB,KAAKC,UAAUpB,KACbmB,KAAKC,UAAUf,EAAML,gBACtBK,EAAML,cAAcvF,QAErB6F,GAAS,SAAAO,GAAI,sBAAUA,EAAV,CAAgBb,gBAAeC,SAAS,OAPnC,2CAAF,kDAAC,MAYtB,IAEGoB,EAAiB/B,EAAYe,EAAO,IAE1CV,qBAAU,WAQR,OAPAgB,EAAiBK,gBACjBL,EAAiBO,uBAEjBxD,UAAQ/C,QAAQ2G,UAAUC,YACxBZ,EAAiBO,sBAGZ,kBAELxD,UAAQ/C,QAAQ2G,UAAUE,eACxBb,EAAiBO,yBAEpB,IAEH,IAAMvF,EAAQiF,mBACZ,iBAAO,CACLP,MAAOgB,EACPf,SAAUK,KAEZ,CAACU,IAGH,OACE,kBAAClB,EAAasB,SAAd,CAAuB9F,MAAOA,GAC3B6E,EAAMkB,Y,uKCtGPC,EAAaC,IAAMC,MAAK,kBAC5B,uDAGIC,EAAQC,YAAe,CAC3BC,QAAS,CACPC,KAAM,UAgBKC,EAZO,WACpB,OACE,kBAACC,EAAA,EAAD,CAAeL,MAAOA,GACpB,kBAAC,WAAD,CAAUM,SAAU,MAClB,kBAAC,IAAD,KACE,kBAACT,EAAD,UCbVU,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,W","file":"static/js/main.63a5f38f.chunk.js","sourcesContent":["// Polyfill\nimport { browser } from 'webextension-polyfill-ts';\n\n// Types\nimport {\n  TypeCookie,\n  TypeExtendedCookie,\n  TypeCookieState,\n  TypeBadge,\n  TypeCookiesState,\n  TypeSetDetailsTypeCookie,\n} from 'types/GlobalTypes';\n\n// Helpers\nimport { sum, groupBy, sortBy } from 'ramda';\nimport {\n  formatDistanceToNow,\n  fromUnixTime,\n  format,\n  addHours,\n  getUnixTime,\n  parse,\n} from 'date-fns';\nimport * as R from 'ramda';\n\nimport parseDomain, { ParsedDomain } from 'parse-domain';\n\n// Ramda Functions\nexport const groupCookiesByDomain = groupBy(\n  (cookie: TypeCookie) => cookie.domain\n);\nexport const sortCookiesByDomain = sortBy(\n  (mappedCookies: TypeCookieState) => mappedCookies.domain.length\n);\n\nexport const DATE_TIME_FORMAT = \"yyyy-MM-dd'T'HH:mm\";\n\nexport const perfTracker = async (name: string, fnc: () => void) => {\n  console.time(name);\n  await fnc();\n  console.timeEnd(name);\n};\n\nexport const getCookiesSize = (\n  cookies: Array<TypeCookie>,\n  returnNumber: boolean = false\n) => {\n  const sizes = cookies.map(cookie => calculateOneCookieSize(cookie) as number);\n  const size = sum(sizes);\n  if (returnNumber) return size;\n  return humanReadableSize(size);\n};\n\nexport const humanReadableSize = (size: number) =>\n  size > 1000 ? `${(size / 1000).toFixed(2)} kb` : `${size} bytes`;\n\nexport const getSizeOfValues = (...args: string[]) =>\n  Buffer.byteLength(args.join(''));\n\nexport const calculateOneCookieSize = (\n  cookie: TypeCookie,\n  humanReadable: boolean = false\n) => {\n  const size = getSizeOfValues(cookie.name, cookie.value);\n  if (humanReadable) return humanReadableSize(size);\n  return size;\n};\n\nexport const getCurrentUrlFromTab = (fullUrl: string | undefined | null) => {\n  if (R.isEmpty(fullUrl) || R.isNil(fullUrl)) {\n    return null;\n  }\n\n  const parsedDomainUrl = parseDomain(fullUrl as string);\n  if (!parsedDomainUrl) {\n    return null;\n  }\n\n  const currentUrl =\n    parsedDomainUrl?.subdomain === '' || parsedDomainUrl?.subdomain === 'www'\n      ? [parsedDomainUrl.domain, parsedDomainUrl.tld].join('.')\n      : [\n          parsedDomainUrl?.subdomain,\n          parsedDomainUrl?.domain,\n          parsedDomainUrl?.tld,\n        ].join('.');\n  return currentUrl;\n};\n\nexport const formatNewCookie = (\n  cookie: TypeExtendedCookie,\n  currentUrl: string\n): TypeSetDetailsTypeCookie => {\n  const PICK_FIELDS: Array<keyof TypeExtendedCookie> = [\n    'name',\n    'storeId',\n    'value',\n    'expirationDate',\n    'path',\n    'httpOnly',\n    'secure',\n  ];\n\n  const secure = currentUrl.indexOf('https://') === 0;\n  const hostOnlyDomain =\n    cookie.domain.substr(0, 1) === '.'\n      ? cookie.domain.substring(1)\n      : cookie.domain;\n  // @ts-ignore\n  return {\n    ...R.pick(PICK_FIELDS, {\n      ...cookie,\n      expirationDate: getUnixTime(\n        parse(cookie.expirationDateString, DATE_TIME_FORMAT, new Date())\n      ),\n    }),\n    ...(!cookie.hostOnly && Boolean(cookie.domain.substr(0, 1) === '.')\n      ? { domain: hostOnlyDomain }\n      : {}),\n    url: `http${secure ? 's' : ''}://${hostOnlyDomain}${cookie.path}`,\n  };\n};\n\nexport const getURL = (url: string | null) => {\n  if (!url) return '';\n  try {\n    const domain = new URL(url).hostname;\n    return domain === 'newtab' ? '' : domain.replace('www.', '');\n  } catch (error) {\n    return '';\n  }\n};\n\nexport const currentTab = async () => {\n  const tab = await browser.tabs.query({\n    active: true,\n    currentWindow: true,\n  });\n  return tab[0];\n};\n\nexport const getAllCookies = async () => {\n  const tab = await currentTab();\n  const parsedDomain = parseDomain(tab.url as string) as ParsedDomain;\n\n  const cookies = await browser.cookies.getAll(\n    parsedDomain\n      ? {\n          domain: `${parsedDomain.domain}.${parsedDomain.tld}`,\n        }\n      : { url: tab.url }\n  );\n\n  const mappedCookies = Object.entries(groupCookiesByDomain(cookies)).map(\n    ([key, value]) => {\n      const size = getCookiesSize(value, true) as number;\n      return {\n        domain: key,\n        size,\n        formatedSize: humanReadableSize(size),\n        cookies: value.map((cookie: TypeCookie) => {\n          const cookieSize = calculateOneCookieSize(cookie) as number;\n          const newCookie: TypeExtendedCookie = {\n            ...cookie,\n            size: cookieSize,\n            formatedSize: humanReadableSize(cookieSize),\n            expirationMessage: getExpirationDate(cookie),\n            expirationDateString: getExpirationDateString(\n              cookie.expirationDate\n            ),\n            badges: generateBadges(cookie),\n          };\n          return newCookie;\n        }),\n      };\n    },\n    []\n  );\n  return sortCookiesByDomain(mappedCookies) as TypeCookiesState;\n};\n\nexport const compareCookies = (\n  newCookies: TypeCookiesState,\n  oldCookies: TypeCookiesState\n) => JSON.stringify(newCookies) === JSON.stringify(oldCookies);\n\nexport const getExpirationDate = (cookie: TypeCookie) => {\n  if (cookie.session) return 'Session';\n  if (!cookie.expirationDate) return null;\n\n  return formatDistanceToNow(fromUnixTime(cookie.expirationDate));\n};\n\nexport const getExpirationDateString = (\n  time: number | null | undefined = null\n) => {\n  return format(\n    time ? fromUnixTime(time) : addHours(new Date(), 1),\n    DATE_TIME_FORMAT\n  );\n};\n\nexport const generateBadges = (cookie: TypeCookie) => {\n  let badges: Array<TypeBadge> = [];\n\n  if (cookie.httpOnly)\n    badges.push({\n      badgeName: 'HttpOnly',\n    });\n  if (cookie.secure)\n    badges.push({\n      badgeName: 'Secure',\n    });\n\n  return badges;\n};\n","import { useState, useEffect } from 'react';\n\nconst useDebounce = (value: any, delay: number = 750) => {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n    return () => clearTimeout(handler);\n  }, [value, delay]);\n\n  return debouncedValue;\n};\n\nexport default useDebounce;\n","import React, {\n  ReactChild,\n  createContext,\n  useState,\n  useMemo,\n  useEffect,\n} from 'react';\nimport { TypeExtendedCookie, TypeCookiesState } from 'types/GlobalTypes';\nimport { Tabs, browser } from 'webextension-polyfill-ts';\nimport { currentTab, getAllCookies } from 'helpers/CookieHelper';\nimport useDebounce from 'hooks/useDebounce';\n\nexport interface IGlobalState {\n  domainCookies: TypeCookiesState;\n  loading: boolean;\n  newCookie: boolean;\n  cookie: TypeExtendedCookie | null;\n  currentTab: Tabs.Tab | null;\n}\n\nconst DEFAULT_GLOBAL_CONTEXT: IGlobalState = {\n  domainCookies: [],\n  loading: true,\n  cookie: null,\n  newCookie: false,\n  currentTab: null,\n};\n\ninterface ISetStore {\n  newCookie: () => void;\n  editCookie: (cookie: TypeExtendedCookie) => void;\n  clearCookie: () => void;\n  setCurrentTab: () => any;\n  loadAllComainCookies: () => any;\n}\n\nexport const StoreContext = createContext<{\n  state: IGlobalState;\n  setState: ISetStore;\n}>(\n  // @ts-ignore\n  { state: DEFAULT_GLOBAL_CONTEXT, setState: null }\n);\n\nexport type IStore = [IGlobalState, ISetStore];\n\ninterface Props {\n  children: React.ReactNode | ReactChild;\n}\n\nfunction Store(props: Props) {\n  const [state, setState] = useState(DEFAULT_GLOBAL_CONTEXT);\n  // @ts-ignore\n  window.easyCookieEditor = state;\n\n  const memoizedSetState = useMemo(() => {\n    const storeActions: ISetStore = {\n      newCookie: () => setState(prev => ({ ...prev, newCookie: true })),\n      editCookie: cookie => setState(prev => ({ ...prev, cookie })),\n      clearCookie: () =>\n        setState(prev => ({ ...prev, cookie: null, newCookie: false })),\n      setCurrentTab: async () => {\n        const _currentTab = await currentTab();\n        setState(prev => ({ ...prev, currentTab: _currentTab }));\n      },\n      loadAllComainCookies: async () => {\n        const domainCookies = await getAllCookies();\n        if (\n          JSON.stringify(domainCookies) !==\n            JSON.stringify(state.domainCookies) ||\n          !state.domainCookies.length\n        ) {\n          setState(prev => ({ ...prev, domainCookies, loading: false }));\n        }\n      },\n    };\n    return storeActions;\n  }, []);\n\n  const debouncedState = useDebounce(state, 50);\n\n  useEffect(() => {\n    memoizedSetState.setCurrentTab();\n    memoizedSetState.loadAllComainCookies();\n    // @ts-ignore\n    browser.cookies.onChanged.addListener(\n      memoizedSetState.loadAllComainCookies\n    );\n\n    return () =>\n      // @ts-ignore\n      browser.cookies.onChanged.removeListener(\n        memoizedSetState.loadAllComainCookies\n      );\n  }, []);\n\n  const value = useMemo(\n    () => ({\n      state: debouncedState,\n      setState: memoizedSetState,\n    }),\n    [debouncedState]\n  );\n\n  return (\n    <StoreContext.Provider value={value}>\n      {props.children}\n    </StoreContext.Provider>\n  );\n}\n\nexport default Store;\n","import React, { Suspense } from 'react';\nimport { ThemeProvider, createMuiTheme } from '@material-ui/core/styles';\nimport Store from 'store/GlobalStore';\n\nconst MainScreen = React.lazy(() =>\n  import('./components/Cookies/List/MainScreen')\n); // Lazy-loaded\n\nconst theme = createMuiTheme({\n  palette: {\n    type: 'dark',\n  },\n});\n\nconst App: React.FC = () => {\n  return (\n    <ThemeProvider theme={theme}>\n      <Suspense fallback={null}>\n        <Store>\n          <MainScreen />\n        </Store>\n      </Suspense>\n    </ThemeProvider>\n  );\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n// import * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n// serviceWorker.register();\n"],"sourceRoot":""}